import asyncio
import hashlib
import aiohttp
import os
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, List

from .base import BaseScanner, ScanResult


class MalwareBazaarScanner(BaseScanner):
    """
    MalwareBazaar API scanner for threat intelligence lookup.
    Checks file hashes against MalwareBazaar database for known threats.
    """
    
    def __init__(self):
        super().__init__("malwarebazaar")
        self.api_url = "https://mb-api.abuse.ch/api/v1/"
        self.timeout = int(os.environ.get('MALWAREBazaar_TIMEOUT', '10'))  # seconds from environment variable
        self.session: Optional[aiohttp.ClientSession] = None
        self.offline_mode = False  # Will be set during initialization
        
        # Get API keys directly from environment variables (works in both main and child containers)
        self.api_keys = []
        
        # Get API keys from environment variables
        env_primary = os.environ.get('MALWAREBazaar_API_KEY')
        env_backup = os.environ.get('MALWAREBazaar_API_KEY_BACKUP')
        
        if env_primary:
            self.api_keys.append(env_primary)
        if env_backup:
            self.api_keys.append(env_backup)
        
        self.current_api_key = None
        
    async def initialize(self) -> None:
        """Initialize the scanner"""
        print("DEBUG: MalwareBazaar scanner initializing...")
        
        # Create HTTP session with proper headers
        connector = aiohttp.TCPConnector(limit=10, limit_per_host=5)
        timeout = aiohttp.ClientTimeout(total=self.timeout)
        
        self.session = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={
                'User-Agent': 'MalwareAnalysisSystem/1.0'
            }
        )
        
        # Test API keys and network connectivity
        print("DEBUG: MalwareBazaar testing API keys and network connectivity...")
        self.offline_mode = True  # Start pessimistic
        
        for i, api_key in enumerate(self.api_keys):
            try:
                print(f"DEBUG: MalwareBazaar testing API key {i+1}...")
                
                # Use a valid API query to test connectivity and authentication
                test_data = {
                    'query': 'get_info',
                    'hash': 'deadbeefdeadbeefdeadbeefdeadbeef'  # Non-existent hash for testing
                }
                
                async with self.session.post(
                    self.api_url, 
                    data=test_data,
                    headers={
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Auth-Key': api_key
                    }
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        
                        # Check response for authentication success
                        if result.get('error') == 'Unauthorized':
                            print(f"DEBUG: MalwareBazaar API key {i+1} failed authentication")
                            continue
                        elif result.get('query_status') in ['hash_not_found', 'ok']:
                            print(f"DEBUG: MalwareBazaar API key {i+1} authentication successful")
                            self.current_api_key = api_key
                            self.offline_mode = False
                            break
                        else:
                            print(f"DEBUG: MalwareBazaar API key {i+1} returned unexpected response: {result}")
                            continue
                    else:
                        print(f"DEBUG: MalwareBazaar API key {i+1} returned status {response.status}")
                        continue
                        
            except Exception as e:
                print(f"DEBUG: MalwareBazaar API key {i+1} test failed: {e}")
                continue
        
        if self.offline_mode:
            print("WARNING: All MalwareBazaar API keys failed. Operating in offline mode.")
        else:
            print(f"DEBUG: MalwareBazaar initialized successfully with API key")
        
        print("DEBUG: MalwareBazaar scanner initialized successfully")
        self.initialized = True
        
    async def cleanup(self) -> None:
        """Cleanup resources"""
        if self.session:
            await self.session.close()
            self.session = None
        print("DEBUG: MalwareBazaar scanner cleanup completed")
    
    def _calculate_file_hashes(self, file_path: Path) -> Dict[str, str]:
        """Calculate MD5, SHA1, and SHA256 hashes of the file"""
        hashes = {'md5': '', 'sha1': '', 'sha256': ''}
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
                
            hashes['md5'] = hashlib.md5(content).hexdigest()
            hashes['sha1'] = hashlib.sha1(content).hexdigest() 
            hashes['sha256'] = hashlib.sha256(content).hexdigest()
            
            print(f"DEBUG: MalwareBazaar calculated hashes - MD5: {hashes['md5'][:16]}..., SHA256: {hashes['sha256'][:16]}...")
            
        except Exception as e:
            print(f"ERROR: MalwareBazaar failed to calculate hashes: {e}")
            
        return hashes
    
    async def _query_malwarebazaar(self, hash_value: str, hash_type: str) -> Optional[Dict[str, Any]]:
        """Query MalwareBazaar API for hash information"""
        if not self.session:
            return None
            
        try:
            data = {
                'query': 'get_info',
                'hash': hash_value
            }
            
            print(f"DEBUG: MalwareBazaar querying {hash_type.upper()}: {hash_value[:16]}...")
            
            async with self.session.post(
                self.api_url, 
                data=data,
                headers={
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Auth-Key': self.current_api_key
                }
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    
                    # Check if API requires authentication
                    if result.get('error') == 'Unauthorized':
                        print(f"ERROR: MalwareBazaar API authentication failed - {hash_type.upper()} query failed")
                        return None
                    # Check if we got a valid response
                    elif result.get('query_status') == 'ok':
                        print(f"DEBUG: MalwareBazaar found match for {hash_type.upper()}")
                        data = result.get('data', [])
                        if data:
                            print(f"DEBUG: MalwareBazaar API response data: {data[0] if isinstance(data, list) else data}")
                        return data
                    elif result.get('query_status') == 'hash_not_found':
                        print(f"DEBUG: MalwareBazaar - {hash_type.upper()} not found in database")
                        return None
                    else:
                        print(f"DEBUG: MalwareBazaar query failed: {result.get('query_status', 'unknown error')}")
                        return None
                else:
                    print(f"ERROR: MalwareBazaar API returned status {response.status}")
                    return None
                    
        except asyncio.TimeoutError:
            print("ERROR: MalwareBazaar API request timed out")
            return None
        except Exception as e:
            print(f"ERROR: MalwareBazaar API request failed: {e}")
            print(f"ERROR: MalwareBazaar exception type: {type(e).__name__}")
            # For debugging network issues
            if "name resolution" in str(e).lower():
                print("ERROR: MalwareBazaar - DNS resolution failed. Container may not have internet access.")
            elif "connection" in str(e).lower():
                print("ERROR: MalwareBazaar - Connection failed. API may be down or blocked.")
            return None
    
    def _parse_malwarebazaar_response(self, data: list) -> tuple[list, float, Dict[str, Any]]:
        """Parse MalwareBazaar response and extract threat information"""
        threats = []
        confidence = 0.0
        details = {}
        
        if not data:
            return threats, confidence, details
            
        # Get the first (most recent) entry
        entry = data[0] if isinstance(data, list) else data
        
        # Debug: Show all available fields
        print(f"DEBUG: MalwareBazaar entry fields: {list(entry.keys()) if isinstance(entry, dict) else 'Not a dict'}")
        
        # Extract detailed information (handle None values)
        signature = entry.get('signature')
        tags = entry.get('tags', []) or []
        delivery_method = entry.get('delivery_method') or 'Unknown'
        first_seen = entry.get('first_seen') or 'Unknown'
        file_name = entry.get('file_name') or 'Unknown file'
        
        # Extract threat information from vendor intelligence
        vendor_intel = entry.get('vendor_intel', {})
        yara_rules = entry.get('yara_rules', [])
        
        print(f"DEBUG: MalwareBazaar parsed - signature: '{signature}', tags: {tags}, vendor_intel keys: {list(vendor_intel.keys()) if vendor_intel else []}")
        
        # Build comprehensive threat description
        threat_parts = []
        
        # Check vendor intelligence for threat names
        threat_names = []
        if vendor_intel:
            for vendor, intel in vendor_intel.items():
                if isinstance(intel, dict):
                    threat_name = intel.get('threat_name') or intel.get('detection')
                    if threat_name and threat_name.lower() not in ['none', 'unknown']:
                        threat_names.append(f"{threat_name} ({vendor})")
                elif isinstance(intel, list):
                    for item in intel:
                        if isinstance(item, dict):
                            detection = item.get('detection')
                            if detection and detection.lower() not in ['none', 'unknown']:
                                threat_names.append(f"{detection} ({vendor})")
        
        # Use YARA rule names if available
        yara_detections = []
        for rule in yara_rules:
            if isinstance(rule, dict):
                rule_name = rule.get('rule_name')
                if rule_name:
                    yara_detections.append(f"YARA: {rule_name}")
        
        # Build main threat description
        if signature and signature.lower() not in ['none', 'unknown']:
            threat_desc = f"Malware: {signature}"
        elif threat_names:
            threat_desc = f"Malware: {threat_names[0]}"
        elif yara_detections:
            threat_desc = f"Suspicious: {yara_detections[0]}"
        elif tags:
            # Use tags to build description
            suspicious_tags = [tag for tag in tags if not any(x in tag.lower() for x in ['com', 'org', 'net', 'pdf', 'doc'])]
            if suspicious_tags:
                threat_desc = f"Suspicious file with indicators: {', '.join(suspicious_tags[:2])}"
            else:
                threat_desc = f"Known suspicious file: {file_name}"
        else:
            threat_desc = f"Known malicious file: {file_name}"
            
        threats.append(threat_desc)
        
        # Set high confidence for MalwareBazaar matches
        confidence = 0.9
        
        # Store detailed information
        details.update({
            'malwarebazaar_signature': signature,
            'file_name': file_name,
            'tags': tags,
            'delivery_method': delivery_method,
            'first_seen': first_seen,
            'threat_source': 'MalwareBazaar',
            'vendor_detections': threat_names,
            'yara_rules': [rule.get('rule_name') for rule in yara_rules if isinstance(rule, dict) and rule.get('rule_name')],
            'file_type': entry.get('file_type'),
            'reporter': entry.get('reporter'),
            'origin_country': entry.get('origin_country')
        })
        
        # Add additional threat descriptions from vendor intelligence
        if threat_names:
            for threat_name in threat_names[1:3]:  # Add up to 2 additional vendor detections
                threats.append(threat_name)
        
        # Add YARA rule detections
        if yara_detections:
            for yara_detection in yara_detections[:2]:  # Add up to 2 YARA detections
                threats.append(yara_detection)
        
        # Add tag-based threats for known malicious behaviors
        if tags:
            tag_threats = []
            malicious_indicators = ['trojan', 'ransomware', 'backdoor', 'spyware', 'adware', 'rootkit', 'phishing', 'malware']
            for tag in tags:
                if any(indicator in tag.lower() for indicator in malicious_indicators):
                    tag_threats.append(f"Behavioral indicator: {tag}")
            
            if tag_threats:
                threats.extend(tag_threats[:2])  # Limit to 2 behavioral indicators
                details['behavioral_indicators'] = tag_threats
        
        print(f"DEBUG: MalwareBazaar parsed threats: {threats}")
        print(f"DEBUG: MalwareBazaar confidence: {confidence}")
        
        return threats, confidence, details

    def _get_human_readable_threats(self, threat_data: Dict) -> List[str]:
        """Convert MalwareBazaar technical threat descriptions to human-readable keywords."""
        threats = []
        
        # Extract threat type from tags
        if 'tags' in threat_data:
            for tag in threat_data['tags']:
                if tag.lower() in ['trojan', 'backdoor', 'keylogger', 'ransomware', 'spyware']:
                    threats.append(tag.lower().title())
                elif 'trojan' in tag.lower():
                    threats.append('Trojan')
                elif 'backdoor' in tag.lower():
                    threats.append('Backdoor')
                elif 'keylogger' in tag.lower():
                    threats.append('Keylogger')
                elif 'ransomware' in tag.lower():
                    threats.append('Ransomware')
                elif 'spyware' in tag.lower():
                    threats.append('Spyware')
                elif 'malware' in tag.lower():
                    threats.append('Malware')
                elif 'virus' in tag.lower():
                    threats.append('Virus')
        
        # Extract from threat name if available
        if 'threat_name' in threat_data and threat_data['threat_name']:
            threat_name = threat_data['threat_name'].lower()
            if 'trojan' in threat_name:
                threats.append('Trojan')
            elif 'backdoor' in threat_name:
                threats.append('Backdoor')
            elif 'keylogger' in threat_name:
                threats.append('Keylogger')
            elif 'ransomware' in threat_name:
                threats.append('Ransomware')
            elif 'spyware' in threat_name:
                threats.append('Spyware')
            elif 'malware' in threat_name:
                threats.append('Malware')
            elif 'virus' in threat_name:
                threats.append('Virus')
        
        # Extract from description if available
        if 'description' in threat_data and threat_data['description']:
            desc = threat_data['description'].lower()
            if 'trojan' in desc:
                threats.append('Trojan')
            elif 'backdoor' in desc:
                threats.append('Backdoor')
            elif 'keylogger' in desc:
                threats.append('Keylogger')
            elif 'ransomware' in desc:
                threats.append('Ransomware')
            elif 'spyware' in desc:
                threats.append('Spyware')
            elif 'malware' in desc:
                threats.append('Malware')
            elif 'virus' in desc:
                threats.append('Virus')
        
        # Remove duplicates and return
        return list(set(threats)) if threats else ['Suspicious']
    
    async def scan(self, file_path: Path) -> ScanResult:
        """
        Scan file using MalwareBazaar threat intelligence
        """
        print(f"DEBUG: MalwareBazaar scanner starting scan of: {file_path}")
        
        if not self.initialized:
            print("DEBUG: MalwareBazaar not initialized, initializing now...")
            await self.initialize()
        
        # Skip API calls if in offline mode
        if self.offline_mode:
            print("DEBUG: MalwareBazaar operating in offline mode - skipping API calls")
            return ScanResult(
                safe=True,
                threats=[],
                scan_time=datetime.utcnow(),
                file_size=file_path.stat().st_size,
                file_name=file_path.name,
                scan_engine=self.name,
                confidence=0.0,
                details={"status": "offline_mode", "message": "No internet access for threat intelligence"}
            )
            
        try:
            # Check if file exists
            if not file_path.exists():
                print(f"ERROR: MalwareBazaar - File not found: {file_path}")
                return ScanResult(
                    safe=True,
                    threats=[],
                    scan_time=datetime.utcnow(),
                    file_size=0,
                    file_name=file_path.name,
                    scan_engine=self.name,
                    confidence=0.0,
                    error="File not found"
                )
            
            # Calculate file hashes
            print("DEBUG: MalwareBazaar calculating file hashes...")
            hashes = self._calculate_file_hashes(file_path)
            
            if not any(hashes.values()):
                print("ERROR: MalwareBazaar failed to calculate any file hashes")
                return ScanResult(
                    safe=True,
                    threats=[],
                    scan_time=datetime.utcnow(),
                    file_size=file_path.stat().st_size,
                    file_name=file_path.name,
                    scan_engine=self.name,
                    confidence=0.0,
                    error="Failed to calculate file hashes"
                )
            
            # Query MalwareBazaar with different hash types (prioritize SHA256, then MD5, then SHA1)
            malware_data = None
            matched_hash_type = None
            
            for hash_type in ['sha256', 'md5', 'sha1']:
                if hashes[hash_type]:
                    result = await self._query_malwarebazaar(hashes[hash_type], hash_type)
                    if result:
                        malware_data = result
                        matched_hash_type = hash_type
                        print(f"DEBUG: MalwareBazaar match found using {hash_type.upper()}")
                        break
            
            # Parse results
            threats = []
            confidence = 0.0
            details = {'file_hashes': hashes}
            
            if malware_data:
                threats, confidence, threat_details = self._parse_malwarebazaar_response(malware_data)
                # Convert to human-readable threats
                human_threats = self._get_human_readable_threats(threat_details)
                details.update(threat_details)
                details['matched_hash_type'] = matched_hash_type
                details['original_threats'] = threats  # Keep original for debugging
                print(f"DEBUG: MalwareBazaar identified as malware with confidence {confidence}")
            else:
                print("DEBUG: MalwareBazaar - File not found in threat intelligence database")
                details['malwarebazaar_status'] = 'not_found'
                human_threats = []
            
            print(f"DEBUG: MalwareBazaar analysis complete. Human-readable threats: {human_threats}")
            
            result = ScanResult(
                safe=len(human_threats) == 0,
                threats=human_threats,
                scan_time=datetime.utcnow(),
                file_size=file_path.stat().st_size,
                file_name=file_path.name,
                scan_engine=self.name,
                confidence=confidence,
                details=details
            )
            
            print(f"DEBUG: MalwareBazaar returning result: safe={result.safe}, threats={len(result.threats)}")
            return result
            
        except Exception as e:
            print(f"ERROR: MalwareBazaar scanner exception: {str(e)}")
            print(f"ERROR: MalwareBazaar exception type: {type(e).__name__}")
            import traceback
            print(f"ERROR: MalwareBazaar traceback: {traceback.format_exc()}")
            
            return ScanResult(
                safe=True,
                threats=[],
                scan_time=datetime.utcnow(),
                file_size=file_path.stat().st_size if file_path.exists() else 0,
                file_name=file_path.name,
                scan_engine=self.name,
                confidence=0.0,
                error=str(e)
            )
